% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aopts.R
\name{aopts}
\alias{aopts}
\title{Autoregressive Ordinal Probit Model for Categorical Time Series}
\usage{
aopts(
  y,
  X,
  method = c("clse", "pl"),
  control = list(reltol = 1e-07, maxit = 1000),
  optim_method = "BFGS"
)
}
\arguments{
\item{y}{Integer or factor vector of length \eqn{T}. If a factor, levels must
be ordered. Internally, values are mapped to \code{1, ..., K}.}

\item{X}{Design matrix of dimension \eqn{T \times p}. Include an intercept
column if desired.}

\item{method}{Estimation method. Supported: \code{"clse"} and \code{"pl"}.}

\item{control}{List of control arguments passed to the optimizer.
For \code{"clse"}, this is passed to \code{\link[stats]{constrOptim}}.
For \code{"pl"}, this is passed to \code{\link[stats]{optim}} (with
method-specific entries such as \code{order_pair_lik} and \code{ar_order}
handled internally and not forwarded to \code{optim}).}

\item{optim_method}{Optimization method passed to the optimizer
(e.g., \code{"BFGS"}, \code{"CG"}).}
}
\value{
An object of class \code{"aopts_fit"} with components:
\itemize{
\item \code{method}: Estimation method used.
\item \code{par}: Estimated parameter vector.
\item \code{se}: Standard errors. For \code{"clse"}, these are based on the
sandwich variance \eqn{V = H^{-1} W H^{-1}} when available. For \code{"pl"},
these are based on the Godambe/sandwich variance when available; otherwise
\code{NA}.
\item \code{vcov_sand}: Robust sandwich (Godambe) variance-covariance matrix
when available; otherwise \code{NULL} or an \code{NA} matrix.
\item \code{K}, \code{T}, \code{p}: Model dimensions.
\item \code{par_map}: Decoded parameter blocks: \code{cut}, \code{beta},
\code{rho}.
\item \code{value}, \code{convergence}, \code{message}: Optimizer outputs.
}
}
\description{
Main entry point for fitting autoregressive ordinal probit models for
categorical time series.
}
\details{
Currently supports Conditional Least Squares Estimation (method = "clse")
and Maximum Pairwise (Composite) Log-Likelihood (method = "pl"), implemented
via native routines registered in the package shared library.

The package compiles the C/C++ source in \code{src/} into a single shared
library that R loads automatically. Native calls are made with
\code{PACKAGE="TSAOP"} and require that the corresponding routines are
registered (see \code{useDynLib(TSAOP, .registration=TRUE)} in the
\code{NAMESPACE} file). Users should not call \code{dyn.load()} or pass a
\code{.so} path directly.

\strong{Implemented / planned methods.}
\itemize{
\item \code{"clse"} (Conditional Least Squares; implemented).
\itemize{
\item \emph{Parameter estimation:} Parameters are estimated by minimizing
the CLS objective via \code{\link[stats]{constrOptim}} subject to
monotonicity constraints on cutpoints and bounds on \code{rho}.
\item \emph{Standard error approximation:} Robust (sandwich) variance
estimator:
\deqn{V = H^{-1} W H^{-1},}
where \eqn{H} is the Hessian of the CLS objective and \eqn{W} is the
variability matrix returned by the native routine
\code{score_by_t_CLSEW_aop}. (Despite its name, this routine returns the
aggregated \eqn{W} matrix rather than a per-time score matrix.)
}
\item \code{"pl"} (Maximum pairwise log-likelihood; implemented).
\itemize{
\item \emph{Parameter estimation:} Parameters are estimated by maximizing
the (average) pairwise/composite log-likelihood using
\code{\link[stats]{optim}} on an unconstrained transformed parameterization
(cutpoint differences and AR parameters transformed to enforce constraints).
\item \emph{Standard error approximation:} When available, a robust
Godambe/sandwich variance estimator of the form
\deqn{V = H^{-1} J H^{-1}}
is returned in \code{vcov_sand}, where \eqn{H} is the Hessian (in the
original parameterization) and \eqn{J} is a variability matrix constructed
from composite-score contributions. If unavailable, standard errors are
returned as \code{NA}.
}
\item \code{"lse"} (Least squares estimator; \emph{TBA}).
}
}
\examples{
## Example 1: Simulated ordinal time series with AR(1) latent correlation

T  <- 600
K  <- 5
t  <- 1:T

# Design matrix: intercept + mild trend + ~30-day seasonality
X <- cbind(
  Intercept = 1,
  Trend     = as.numeric(scale(t, scale = FALSE)),
  c30       = cos(2*pi*t/30),
  s30       = sin(2*pi*t/30)
)

cut_true   <- c(0.5, 1.2, 2.0)
theta_true <- c(-0.5, 0.001, 0.30, -0.10)
rho_true   <- 0.6

sim <- aop_sim(
  ci = cut_true, theta = theta_true, rho = rho_true,
  K = K, Ts = T, DesignX = X, seed = 123
)

fit_clse <- aopts(y = sim$X_hour, X = X, method = "clse")
fit_pl   <- aopts(y = sim$X_hour, X = X, method = "pl")

print(summary(fit_clse))
print(summary(fit_pl))



## Example 2: Simulated ordinal time series with AR(2) latent correlation

T <- 600
K <- 5
t <- 1:T

X <- cbind(
  Intercept = 1,
  Trend = as.numeric(scale(t, scale = FALSE)),
  c30 = cos(2*pi*t/30),
  s30 = sin(2*pi*t/30)
)

cut_true   <- c(0.6, 1.4, 2.4)
theta_true <- c(-0.5, 0.003, 0.20, -0.10)
rho_true   <- c(0.6, 0.3)

sim <- aop_sim(
  ci = cut_true, theta = theta_true, rho = rho_true,
  K = K, Ts = T, DesignX = X, seed = 123)

fit_pl <- aopts(
  y = sim$X_hour, X = X, method = "pl",
  control = list(order_pair_lik = 5L, ar_order = 2L))
print(summary(fit_pl))

}
